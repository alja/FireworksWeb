#!/usr/bin/perl

# use strict;
# Loads the necessary Perl modules for web programming and network communication.
use warnings;
use CGI;
use IO::Socket qw(AF_INET SOCK_STREAM);
use IO::Socket::Timeout;
use File::Basename;

my $q = CGI->new;

my $EVE_HOST = 'localhost';
my $EVE_PORT = 6666;
sub cgi_end
{
  print<<"FNORD";

</body>
</html>
FNORD
}

# Shows an error message and stops the program
sub cgi_die
{
  print "<p><b> $_[0] </b>\n";
  cgi_end();
  exit(1);
}

# Displays formatted text on the web page
sub cgi_print
{
  print "<p><pre>", join("\n", @_), "</pre>\n";
}

sub flush
{
  defined $mod_perl_req ? $mod_perl_req->rflush() : select()->flush();
}

# Connects to the CMS server via network socket
sub connect_to_server
{
  my $request = shift;
  my $verbose = shift;
  my $buf;

  cgi_print "Connecting to local cmsShowWeb forker now ..." if $verbose;

  my $client = IO::Socket->new(
      Domain   => AF_INET,
      Type     => SOCK_STREAM,
      proto    => 'tcp',
      PeerHost => $EVE_HOST,
      PeerPort => $EVE_PORT,
      Timeout  => 5
  ) || cgi_die "Can't open socket: $@";

  IO::Socket::Timeout->enable_timeouts_on($client);

  cgi_print "Connected to $EVE_PORT" if $verbose;

  $buf = recv_with_timeout($client, 1024, 5, 30);
  
  unless (length($buf)) {
    my $err_str = $!;
    cgi_print "Error receiving server greeting, error: ${err_str}.";
    $client->close();
    return $buf;
  }
  cgi_print "Server greeting: $buf" if $verbose;

  cgi_print "Sending $request" if $verbose;

  # MUST include trailing \n, the server is looking for it!

  my $size = $client->send($request);
  cgi_print "Sent data of length: $size" if $verbose;

  flush();

  $buf = recv_with_timeout($client, 1024, 5, 300);
 
  if (length($buf)) {
    cgi_print "Server response: $buf" if $verbose;
  } else {
    my $err_str = $!;
    cgi_print "Error receiving server response, error: ${err_str}.";
  }

  $client->close();

  return $buf;
}

# Receives data with a timeout to prevent hanging
sub recv_with_timeout
{
  my $sock = shift;
  my $size = shift;
  my $timeout = shift || 5;
  my $err_to  = shift || 100;
  my $buf;
  my $sum_t = 0;

  $sock->read_timeout($timeout);

  my $ret;
  while (not defined ($ret = $sock->recv($buf, $size)))
  {
    $sum_t += $timeout;
    cgi_print "Waiting for server response, ${sum_t}s [ max = ${err_to}s ]";
    flush();
    if ($sum_t >= $err_to) {
      return undef;
    }
  }
  chomp  $buf;
  return $buf;
}

 my $buf = connect_to_server(qq{{"action": "report_usage"}\n}, 0);
# Asks for usage statistics
 #
 #
 chomp($buf);
$buf =~ s/\r//g;
$buf =~ s/\0//g;
  if ($buf =~ /^([A-Za-z0-9_]+)$/) {
    $buf = $1;  # now untainted
  } else {
   # die "Bad input";
   }

   my $mark = "Status: currenty serving ";
   if ($buf =~ /(\d+).*?(\d+)/) {
   $mark .= $2;
   $mark .= " total ";
   $mark .= $1;
}

# my $r = eval $buf;
# my $nsess = $r->{current_sessions};
# my $mark = "Currently serving $nsess (total $r->{total_sessions} since service start).";

# Gets the username from CERN authentication
$CERN_UPN   = $ENV{'OIDC_CLAIM_cern_upn'};
# Generates HTML headers
 print $q->header('text/html');
# Creates a page saying "Hello" with the user's name
#print $q->start_html('Hello Page');
# print $q->start_html();
#print $q->h1('Hello from CGI!');
#print $q->p('This HTML was generated by Perl CGI.');
#print $q->p(' user ', $CERN_UPN);
# print $q->end_html;

# Connects to the CMS server
# Displays how many people are currently using the system
  #print "Currently serving $r->{current_sessions} (total $r->{total_sessions} since service start).";

#print "<p>======== pasting other sources below =============================</p>";
# print '<script id="sap-ui-bootstrap" src="https://openui5.hana.ondemand.com/resources/sap-ui-core.js" data-sap-ui-theme="sap_horizon" data-sap-ui-libs="sap.ui.core,sap.m,sap.ui.layout"></script>';
my $file = "ui5-gateway.html";
# Open the file for reading
open(my $fh, '<', $file) or die "Cannot open $file: $!";

# Reads the entire file content into memory
# Slurp mode
local $/;           # Undefine the input record separator
my $html = <$fh>;   # Read entire file at once
close($fh);

# Displays the file content on the web page

$html =~ s/TestUser/$CERN_UPN/g;
$html =~ s/MARK/$mark/g;
print $html;
#print "Currently serving $r->{current_sessions} (total $r->{total_sessions} since service start).";
