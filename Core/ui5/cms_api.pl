#!/usr/bin/perl

# use strict;
# Loads the necessary Perl modules for web programming and network communication.
use warnings;
use CGI;
use IO::Socket qw(AF_INET SOCK_STREAM);
use IO::Socket::Timeout;
use File::Basename;

my $q = CGI->new;

my $EVE_HOST = 'localhost';
my $EVE_PORT = 6666;

sub cgi_end
{
  print<<"FNORD";

</body>
</html>
FNORD
}

# Shows an error message and stops the program
sub cgi_die
{
  print "<p><b> $_[0] </b>\n";
  cgi_end();
  exit(1);
}

# Displays formatted text on the web page
sub cgi_print
{
  print "<p><pre>", join("\n", @_), "</pre>\n";
}

sub flush
{
  defined $mod_perl_req ? $mod_perl_req->rflush() : select()->flush();
}

# Connects to the CMS server via network socket
sub connect_to_server
{
  my $request = shift;
  my $verbose = shift;
  my $buf;

  cgi_print "Connecting to local cmsShowWeb forker now ..." if $verbose;

  my $client = IO::Socket->new(
      Domain   => AF_INET,
      Type     => SOCK_STREAM,
      proto    => 'tcp',
      PeerHost => $EVE_HOST,
      PeerPort => $EVE_PORT,
      Timeout  => 5
  ) || cgi_die "Can't open socket: $@";

  IO::Socket::Timeout->enable_timeouts_on($client);

  cgi_print "Connected to $EVE_PORT" if $verbose;

  $buf = recv_with_timeout($client, 1024, 5, 30);
  
  unless (length($buf)) {
    my $err_str = $!;
    cgi_print "Error receiving server greeting, error: ${err_str}.";
    $client->close();
    return $buf;
  }
  cgi_print "Server greeting: $buf" if $verbose;

  cgi_print "Sending $request" if $verbose;

  # MUST include trailing \n, the server is looking for it!

  my $size = $client->send($request);
  cgi_print "Sent data of length: $size" if $verbose;

  flush();

  $buf = recv_with_timeout($client, 1024, 5, 300);
 
  if (length($buf)) {
    cgi_print "Server response: $buf" if $verbose;
  } else {
    my $err_str = $!;
    cgi_print "Error receiving server response, error: ${err_str}.";
  }

  $client->close();

  return $buf;
}

# Receives data with a timeout to prevent hanging
sub recv_with_timeout
{
  my $sock = shift;
  my $size = shift;
  my $timeout = shift || 5;
  my $err_to  = shift || 100;
  my $buf;
  my $sum_t = 0;

  $sock->read_timeout($timeout);

  my $ret;
  while (not defined ($ret = $sock->recv($buf, $size)))
  {
    $sum_t += $timeout;
    cgi_print "Waiting for server response, ${sum_t}s [ max = ${err_to}s ]";
    flush();
    if ($sum_t >= $err_to) {
      return undef;
    }
  }
  chomp  $buf;
  return $buf;
}

# Gets the username from CERN authentication
$CERN_UPN   = $ENV{'OIDC_CLAIM_cern_upn'};
# Generates HTML headers
print $q->header('text/html');
# Creates a page saying "Hello" with the user's name
print $q->start_html('Hello Page');
print $q->h1('Hello from CGI!');
print $q->p('This HTML was generated by Perl CGI.');
print $q->p(' user ', $CERN_UPN);
# print $q->end_html;

# Connects to the CMS server
my $buf = connect_to_server(qq{{"action": "report_usage"}\n}, 0);

# Asks for usage statistics
my $r = eval $buf;
# Displays how many people are currently using the system
print "Currently serving $r->{current_sessions} (total $r->{total_sessions} since service start).";

print "<p>======== pasting UI5 sources below =============================</p>";

# UI5 Bootstrap first
print '<script id="sap-ui-bootstrap" src="https://openui5.hana.ondemand.com/resources/sap-ui-core.js" data-sap-ui-theme="sap_horizon" data-sap-ui-libs="sap.ui.core,sap.m,sap.ui.layout"></script>';

my $file = "fireworks.html";  
open(my $fh, '<', $file) or die "Cannot open $file: $!";
local $/;
my $html = <$fh>;
close($fh);
print $html;

my @view_files = glob("view/*.view.xml"); 
foreach my $view_file (@view_files) {
    open(my $fh, '<', $view_file) or next;
    local $/;
    my $view_html = <$fh>;
    close($fh);
    print $view_html;
}

# Read your controller files
my @controller_files = glob("controller/*.controller.js"); 
foreach my $controller_file (@controller_files) {
    open(my $fh, '<', $controller_file) or next;
    local $/;
    my $controller_html = <$fh>;
    close($fh);
    print "<script>$controller_html</script>";
}

print $q->end_html;